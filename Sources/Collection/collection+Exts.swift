/**
 * Autogenerated by Thrift Compiler (0.14.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

import Foundation

import Thrift


public func ==(lhs: Palette, rhs: Palette) -> Bool {
  return
    (lhs.accentColour == rhs.accentColour) &&
    (lhs.background == rhs.background) &&
    (lhs.commentCount == rhs.commentCount) &&
    (lhs.elementBackground == rhs.elementBackground) &&
    (lhs.headline == rhs.headline) &&
    (lhs.immersiveKicker == rhs.immersiveKicker) &&
    (lhs.main == rhs.main) &&
    (lhs.mediaBackground == rhs.mediaBackground) &&
    (lhs.mediaIcon == rhs.mediaIcon) &&
    (lhs.metaText == rhs.metaText) &&
    (lhs.pill == rhs.pill) &&
    (lhs.pillar == rhs.pillar) &&
    (lhs.secondary == rhs.secondary) &&
    (lhs.shadow == rhs.shadow) &&
    (lhs.topBorder == rhs.topBorder)
}

extension Palette : CustomStringConvertible {

  public var description : String {
    var desc = "Palette("
    desc += "accentColour=\(String(describing: self.accentColour)), "
    desc += "background=\(String(describing: self.background)), "
    desc += "commentCount=\(String(describing: self.commentCount)), "
    desc += "elementBackground=\(String(describing: self.elementBackground)), "
    desc += "headline=\(String(describing: self.headline)), "
    desc += "immersiveKicker=\(String(describing: self.immersiveKicker)), "
    desc += "main=\(String(describing: self.main)), "
    desc += "mediaBackground=\(String(describing: self.mediaBackground)), "
    desc += "mediaIcon=\(String(describing: self.mediaIcon)), "
    desc += "metaText=\(String(describing: self.metaText)), "
    desc += "pill=\(String(describing: self.pill)), "
    desc += "pillar=\(String(describing: self.pillar)), "
    desc += "secondary=\(String(describing: self.secondary)), "
    desc += "shadow=\(String(describing: self.shadow)), "
    desc += "topBorder=\(String(describing: self.topBorder))"
    return desc
  }

}

extension Palette : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(accentColour)
    hasher.combine(background)
    hasher.combine(commentCount)
    hasher.combine(elementBackground)
    hasher.combine(headline)
    hasher.combine(immersiveKicker)
    hasher.combine(main)
    hasher.combine(mediaBackground)
    hasher.combine(mediaIcon)
    hasher.combine(metaText)
    hasher.combine(pill)
    hasher.combine(pillar)
    hasher.combine(secondary)
    hasher.combine(shadow)
    hasher.combine(topBorder)
  }

}

extension Palette : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["accentColour": 1, "background": 2, "commentCount": 3, "elementBackground": 4, "headline": 5, "immersiveKicker": 6, "main": 7, "mediaBackground": 8, "mediaIcon": 9, "metaText": 10, "pill": 11, "pillar": 12, "secondary": 13, "shadow": 14, "topBorder": 15, ]
  }

  public static var structName: String { return "Palette" }

  public static func read(from proto: TProtocol) throws -> Palette {
    _ = try proto.readStructBegin()
    var accentColour: String!
    var background: String!
    var commentCount: String!
    var elementBackground: String!
    var headline: String!
    var immersiveKicker: String!
    var main: String!
    var mediaBackground: String!
    var mediaIcon: String!
    var metaText: String!
    var pill: String!
    var pillar: String!
    var secondary: String!
    var shadow: String!
    var topBorder: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           accentColour = try String.read(from: proto)
        case (2, .string):           background = try String.read(from: proto)
        case (3, .string):           commentCount = try String.read(from: proto)
        case (4, .string):           elementBackground = try String.read(from: proto)
        case (5, .string):           headline = try String.read(from: proto)
        case (6, .string):           immersiveKicker = try String.read(from: proto)
        case (7, .string):           main = try String.read(from: proto)
        case (8, .string):           mediaBackground = try String.read(from: proto)
        case (9, .string):           mediaIcon = try String.read(from: proto)
        case (10, .string):           metaText = try String.read(from: proto)
        case (11, .string):           pill = try String.read(from: proto)
        case (12, .string):           pillar = try String.read(from: proto)
        case (13, .string):           secondary = try String.read(from: proto)
        case (14, .string):           shadow = try String.read(from: proto)
        case (15, .string):           topBorder = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(accentColour, named: "accentColour")
    try proto.validateValue(background, named: "background")
    try proto.validateValue(commentCount, named: "commentCount")
    try proto.validateValue(elementBackground, named: "elementBackground")
    try proto.validateValue(headline, named: "headline")
    try proto.validateValue(immersiveKicker, named: "immersiveKicker")
    try proto.validateValue(main, named: "main")
    try proto.validateValue(mediaBackground, named: "mediaBackground")
    try proto.validateValue(mediaIcon, named: "mediaIcon")
    try proto.validateValue(metaText, named: "metaText")
    try proto.validateValue(pill, named: "pill")
    try proto.validateValue(pillar, named: "pillar")
    try proto.validateValue(secondary, named: "secondary")
    try proto.validateValue(shadow, named: "shadow")
    try proto.validateValue(topBorder, named: "topBorder")

    return Palette(accentColour: accentColour, background: background, commentCount: commentCount, elementBackground: elementBackground, headline: headline, immersiveKicker: immersiveKicker, main: main, mediaBackground: mediaBackground, mediaIcon: mediaIcon, metaText: metaText, pill: pill, pillar: pillar, secondary: secondary, shadow: shadow, topBorder: topBorder)
  }

}



public func ==(lhs: Links, rhs: Links) -> Bool {
  return
    (lhs.relatedUri == rhs.relatedUri) &&
    (lhs.shortUrl == rhs.shortUrl) &&
    (lhs.uri == rhs.uri) &&
    (lhs.webUri == rhs.webUri)
}

extension Links : CustomStringConvertible {

  public var description : String {
    var desc = "Links("
    desc += "relatedUri=\(String(describing: self.relatedUri)), "
    desc += "shortUrl=\(String(describing: self.shortUrl)), "
    desc += "uri=\(String(describing: self.uri)), "
    desc += "webUri=\(String(describing: self.webUri))"
    return desc
  }

}

extension Links : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(relatedUri)
    hasher.combine(shortUrl)
    hasher.combine(uri)
    hasher.combine(webUri)
  }

}

extension Links : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["relatedUri": 1, "shortUrl": 2, "uri": 3, "webUri": 4, ]
  }

  public static var structName: String { return "Links" }

  public static func read(from proto: TProtocol) throws -> Links {
    _ = try proto.readStructBegin()
    var relatedUri: String!
    var shortUrl: String!
    var uri: String!
    var webUri: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           relatedUri = try String.read(from: proto)
        case (2, .string):           shortUrl = try String.read(from: proto)
        case (3, .string):           uri = try String.read(from: proto)
        case (4, .string):           webUri = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(relatedUri, named: "relatedUri")
    try proto.validateValue(shortUrl, named: "shortUrl")
    try proto.validateValue(uri, named: "uri")
    try proto.validateValue(webUri, named: "webUri")

    return Links(relatedUri: relatedUri, shortUrl: shortUrl, uri: uri, webUri: webUri)
  }

}



public func ==(lhs: Image, rhs: Image) -> Bool {
  return
    (lhs.altText == rhs.altText) &&
    (lhs.caption == rhs.caption) &&
    (lhs.credit == rhs.credit) &&
    (lhs.height == rhs.height) &&
    (lhs.orientation == rhs.orientation) &&
    (lhs.urlTemplate == rhs.urlTemplate) &&
    (lhs.width == rhs.width)
}

extension Image : CustomStringConvertible {

  public var description : String {
    var desc = "Image("
    desc += "altText=\(String(describing: self.altText)), "
    desc += "caption=\(String(describing: self.caption)), "
    desc += "credit=\(String(describing: self.credit)), "
    desc += "height=\(String(describing: self.height)), "
    desc += "orientation=\(String(describing: self.orientation)), "
    desc += "urlTemplate=\(String(describing: self.urlTemplate)), "
    desc += "width=\(String(describing: self.width))"
    return desc
  }

}

extension Image : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(altText)
    hasher.combine(caption)
    hasher.combine(credit)
    hasher.combine(height)
    hasher.combine(orientation)
    hasher.combine(urlTemplate)
    hasher.combine(width)
  }

}

extension Image : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["altText": 1, "caption": 2, "credit": 3, "height": 4, "orientation": 5, "urlTemplate": 6, "width": 7, ]
  }

  public static var structName: String { return "Image" }

  public static func read(from proto: TProtocol) throws -> Image {
    _ = try proto.readStructBegin()
    var altText: String?
    var caption: String?
    var credit: String?
    var height: Int32!
    var orientation: String!
    var urlTemplate: String!
    var width: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           altText = try String.read(from: proto)
        case (2, .string):           caption = try String.read(from: proto)
        case (3, .string):           credit = try String.read(from: proto)
        case (4, .i32):             height = try Int32.read(from: proto)
        case (5, .string):           orientation = try String.read(from: proto)
        case (6, .string):           urlTemplate = try String.read(from: proto)
        case (7, .i32):             width = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(height, named: "height")
    try proto.validateValue(orientation, named: "orientation")
    try proto.validateValue(urlTemplate, named: "urlTemplate")
    try proto.validateValue(width, named: "width")

    return Image(altText: altText, caption: caption, credit: credit, height: height, orientation: orientation, urlTemplate: urlTemplate, width: width)
  }

}



public func ==(lhs: Article, rhs: Article) -> Bool {
  return
    (lhs.id == rhs.id) &&
    (lhs.byline == rhs.byline) &&
    (lhs.images == rhs.images) &&
    (lhs.links == rhs.links) &&
    (lhs.kicker == rhs.kicker) &&
    (lhs.title == rhs.title) &&
    (lhs.trailText == rhs.trailText) &&
    (lhs.rating == rhs.rating) &&
    (lhs.commentCount == rhs.commentCount) &&
    (lhs.publishedDate == rhs.publishedDate) &&
    (lhs.lastUpdatedDate == rhs.lastUpdatedDate) &&
    (lhs.mediaType == rhs.mediaType) &&
    (lhs.durationInSeconds == rhs.durationInSeconds) &&
    (lhs.profileImage == rhs.profileImage) &&
    (lhs.events == rhs.events) &&
    (lhs.paletteLight == rhs.paletteLight) &&
    (lhs.paletteDark == rhs.paletteDark)
}

extension Article : CustomStringConvertible {

  public var description : String {
    var desc = "Article("
    desc += "id=\(String(describing: self.id)), "
    desc += "byline=\(String(describing: self.byline)), "
    desc += "images=\(String(describing: self.images)), "
    desc += "links=\(String(describing: self.links)), "
    desc += "kicker=\(String(describing: self.kicker)), "
    desc += "title=\(String(describing: self.title)), "
    desc += "trailText=\(String(describing: self.trailText)), "
    desc += "rating=\(String(describing: self.rating)), "
    desc += "commentCount=\(String(describing: self.commentCount)), "
    desc += "publishedDate=\(String(describing: self.publishedDate)), "
    desc += "lastUpdatedDate=\(String(describing: self.lastUpdatedDate)), "
    desc += "mediaType=\(String(describing: self.mediaType)), "
    desc += "durationInSeconds=\(String(describing: self.durationInSeconds)), "
    desc += "profileImage=\(String(describing: self.profileImage)), "
    desc += "events=\(String(describing: self.events)), "
    desc += "paletteLight=\(String(describing: self.paletteLight)), "
    desc += "paletteDark=\(String(describing: self.paletteDark))"
    return desc
  }

}

extension Article : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(id)
    hasher.combine(byline)
    hasher.combine(images)
    hasher.combine(links)
    hasher.combine(kicker)
    hasher.combine(title)
    hasher.combine(trailText)
    hasher.combine(rating)
    hasher.combine(commentCount)
    hasher.combine(publishedDate)
    hasher.combine(lastUpdatedDate)
    hasher.combine(mediaType)
    hasher.combine(durationInSeconds)
    hasher.combine(profileImage)
    hasher.combine(events)
    hasher.combine(paletteLight)
    hasher.combine(paletteDark)
  }

}

extension Article : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["id": 1, "byline": 2, "images": 3, "links": 4, "kicker": 5, "title": 6, "trailText": 7, "rating": 8, "commentCount": 9, "publishedDate": 10, "lastUpdatedDate": 11, "mediaType": 12, "durationInSeconds": 13, "profileImage": 14, "events": 15, "paletteLight": 16, "paletteDark": 17, ]
  }

  public static var structName: String { return "Article" }

  public static func read(from proto: TProtocol) throws -> Article {
    _ = try proto.readStructBegin()
    var id: String!
    var byline: String?
    var images: TList<Image>?
    var links: Links!
    var kicker: String?
    var title: String!
    var trailText: String?
    var rating: Int16?
    var commentCount: Int32?
    var publishedDate: String?
    var lastUpdatedDate: String?
    var mediaType: MediaType?
    var durationInSeconds: Int32?
    var profileImage: Image?
    var events: TList<LiveEvent>?
    var paletteLight: Palette?
    var paletteDark: Palette?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           id = try String.read(from: proto)
        case (2, .string):           byline = try String.read(from: proto)
        case (3, .list):            images = try TList<Image>.read(from: proto)
        case (4, .struct):           links = try Links.read(from: proto)
        case (5, .string):           kicker = try String.read(from: proto)
        case (6, .string):           title = try String.read(from: proto)
        case (7, .string):           trailText = try String.read(from: proto)
        case (8, .i16):             rating = try Int16.read(from: proto)
        case (9, .i32):             commentCount = try Int32.read(from: proto)
        case (10, .string):           publishedDate = try String.read(from: proto)
        case (11, .string):           lastUpdatedDate = try String.read(from: proto)
        case (12, .i32):             mediaType = try MediaType.read(from: proto)
        case (13, .i32):             durationInSeconds = try Int32.read(from: proto)
        case (14, .struct):           profileImage = try Image.read(from: proto)
        case (15, .list):            events = try TList<LiveEvent>.read(from: proto)
        case (16, .struct):           paletteLight = try Palette.read(from: proto)
        case (17, .struct):           paletteDark = try Palette.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(id, named: "id")
    try proto.validateValue(links, named: "links")
    try proto.validateValue(title, named: "title")

    return Article(id: id, byline: byline, images: images, links: links, kicker: kicker, title: title, trailText: trailText, rating: rating, commentCount: commentCount, publishedDate: publishedDate, lastUpdatedDate: lastUpdatedDate, mediaType: mediaType, durationInSeconds: durationInSeconds, profileImage: profileImage, events: events, paletteLight: paletteLight, paletteDark: paletteDark)
  }

}



public func ==(lhs: LiveEvent, rhs: LiveEvent) -> Bool {
  return
    (lhs.id == rhs.id) &&
    (lhs.title == rhs.title) &&
    (lhs.body == rhs.body) &&
    (lhs.publishedDate == rhs.publishedDate) &&
    (lhs.lastUpdatedDate == rhs.lastUpdatedDate)
}

extension LiveEvent : CustomStringConvertible {

  public var description : String {
    var desc = "LiveEvent("
    desc += "id=\(String(describing: self.id)), "
    desc += "title=\(String(describing: self.title)), "
    desc += "body=\(String(describing: self.body)), "
    desc += "publishedDate=\(String(describing: self.publishedDate)), "
    desc += "lastUpdatedDate=\(String(describing: self.lastUpdatedDate))"
    return desc
  }

}

extension LiveEvent : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(id)
    hasher.combine(title)
    hasher.combine(body)
    hasher.combine(publishedDate)
    hasher.combine(lastUpdatedDate)
  }

}

extension LiveEvent : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["id": 1, "title": 2, "body": 3, "publishedDate": 4, "lastUpdatedDate": 5, ]
  }

  public static var structName: String { return "LiveEvent" }

  public static func read(from proto: TProtocol) throws -> LiveEvent {
    _ = try proto.readStructBegin()
    var id: String!
    var title: String!
    var body: String!
    var publishedDate: String?
    var lastUpdatedDate: String?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           id = try String.read(from: proto)
        case (2, .string):           title = try String.read(from: proto)
        case (3, .string):           body = try String.read(from: proto)
        case (4, .string):           publishedDate = try String.read(from: proto)
        case (5, .string):           lastUpdatedDate = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(id, named: "id")
    try proto.validateValue(title, named: "title")
    try proto.validateValue(body, named: "body")

    return LiveEvent(id: id, title: title, body: body, publishedDate: publishedDate, lastUpdatedDate: lastUpdatedDate)
  }

}



public func ==(lhs: Card, rhs: Card) -> Bool {
  return
    (lhs.articles == rhs.articles) &&
    (lhs.paletteLight == rhs.paletteLight) &&
    (lhs.paletteDark == rhs.paletteDark) &&
    (lhs.type == rhs.type) &&
    (lhs.boosted == rhs.boosted) &&
    (lhs.compact == rhs.compact) &&
    (lhs.sublinks == rhs.sublinks)
}

extension Card : CustomStringConvertible {

  public var description : String {
    var desc = "Card("
    desc += "articles=\(String(describing: self.articles)), "
    desc += "paletteLight=\(String(describing: self.paletteLight)), "
    desc += "paletteDark=\(String(describing: self.paletteDark)), "
    desc += "type=\(String(describing: self.type)), "
    desc += "boosted=\(String(describing: self.boosted)), "
    desc += "compact=\(String(describing: self.compact)), "
    desc += "sublinks=\(String(describing: self.sublinks))"
    return desc
  }

}

extension Card : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(articles)
    hasher.combine(paletteLight)
    hasher.combine(paletteDark)
    hasher.combine(type)
    hasher.combine(boosted)
    hasher.combine(compact)
    hasher.combine(sublinks)
  }

}

extension Card : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["articles": 1, "paletteLight": 2, "paletteDark": 3, "type": 4, "boosted": 5, "compact": 6, "sublinks": 7, ]
  }

  public static var structName: String { return "Card" }

  public static func read(from proto: TProtocol) throws -> Card {
    _ = try proto.readStructBegin()
    var articles: TList<Article>!
    var paletteLight: Palette?
    var paletteDark: Palette?
    var type: CardType!
    var boosted: Bool?
    var compact: Bool?
    var sublinks: TList<Article>?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .list):            articles = try TList<Article>.read(from: proto)
        case (2, .struct):           paletteLight = try Palette.read(from: proto)
        case (3, .struct):           paletteDark = try Palette.read(from: proto)
        case (4, .i32):             type = try CardType.read(from: proto)
        case (5, .bool):            boosted = try Bool.read(from: proto)
        case (6, .bool):            compact = try Bool.read(from: proto)
        case (7, .list):            sublinks = try TList<Article>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(articles, named: "articles")
    try proto.validateValue(type, named: "type")

    return Card(articles: articles, paletteLight: paletteLight, paletteDark: paletteDark, type: type, boosted: boosted, compact: compact, sublinks: sublinks)
  }

}



public func ==(lhs: Column, rhs: Column) -> Bool {
  return
    (lhs.cards == rhs.cards) &&
    (lhs.paletteLight == rhs.paletteLight) &&
    (lhs.paletteDark == rhs.paletteDark) &&
    (lhs.preferredWidth == rhs.preferredWidth)
}

extension Column : CustomStringConvertible {

  public var description : String {
    var desc = "Column("
    desc += "cards=\(String(describing: self.cards)), "
    desc += "paletteLight=\(String(describing: self.paletteLight)), "
    desc += "paletteDark=\(String(describing: self.paletteDark)), "
    desc += "preferredWidth=\(String(describing: self.preferredWidth))"
    return desc
  }

}

extension Column : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(cards)
    hasher.combine(paletteLight)
    hasher.combine(paletteDark)
    hasher.combine(preferredWidth)
  }

}

extension Column : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["cards": 1, "paletteLight": 2, "paletteDark": 3, "preferredWidth": 4, ]
  }

  public static var structName: String { return "Column" }

  public static func read(from proto: TProtocol) throws -> Column {
    _ = try proto.readStructBegin()
    var cards: TList<Card>!
    var paletteLight: Palette?
    var paletteDark: Palette?
    var preferredWidth: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .list):            cards = try TList<Card>.read(from: proto)
        case (2, .struct):           paletteLight = try Palette.read(from: proto)
        case (3, .struct):           paletteDark = try Palette.read(from: proto)
        case (4, .i32):             preferredWidth = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(cards, named: "cards")
    try proto.validateValue(preferredWidth, named: "preferredWidth")

    return Column(cards: cards, paletteLight: paletteLight, paletteDark: paletteDark, preferredWidth: preferredWidth)
  }

}



public func ==(lhs: Thrasher, rhs: Thrasher) -> Bool {
  return
    (lhs.uri == rhs.uri)
}

extension Thrasher : CustomStringConvertible {

  public var description : String {
    var desc = "Thrasher("
    desc += "uri=\(String(describing: self.uri))"
    return desc
  }

}

extension Thrasher : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(uri)
  }

}

extension Thrasher : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["uri": 1, ]
  }

  public static var structName: String { return "Thrasher" }

  public static func read(from proto: TProtocol) throws -> Thrasher {
    _ = try proto.readStructBegin()
    var uri: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           uri = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(uri, named: "uri")

    return Thrasher(uri: uri)
  }

}



public func ==(lhs: Row, rhs: Row) -> Bool {
  return
    (lhs.columns == rhs.columns) &&
    (lhs.paletteLight == rhs.paletteLight) &&
    (lhs.paletteDark == rhs.paletteDark) &&
    (lhs.preferredNumberOfColumns == rhs.preferredNumberOfColumns) &&
    (lhs.thrasher == rhs.thrasher) &&
    (lhs.type == rhs.type)
}

extension Row : CustomStringConvertible {

  public var description : String {
    var desc = "Row("
    desc += "columns=\(String(describing: self.columns)), "
    desc += "paletteLight=\(String(describing: self.paletteLight)), "
    desc += "paletteDark=\(String(describing: self.paletteDark)), "
    desc += "preferredNumberOfColumns=\(String(describing: self.preferredNumberOfColumns)), "
    desc += "thrasher=\(String(describing: self.thrasher)), "
    desc += "type=\(String(describing: self.type))"
    return desc
  }

}

extension Row : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(columns)
    hasher.combine(paletteLight)
    hasher.combine(paletteDark)
    hasher.combine(preferredNumberOfColumns)
    hasher.combine(thrasher)
    hasher.combine(type)
  }

}

extension Row : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["columns": 1, "paletteLight": 2, "paletteDark": 3, "preferredNumberOfColumns": 4, "thrasher": 5, "type": 6, ]
  }

  public static var structName: String { return "Row" }

  public static func read(from proto: TProtocol) throws -> Row {
    _ = try proto.readStructBegin()
    var columns: TList<Column>?
    var paletteLight: Palette?
    var paletteDark: Palette?
    var preferredNumberOfColumns: Int32?
    var thrasher: Thrasher?
    var type: RowType!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .list):            columns = try TList<Column>.read(from: proto)
        case (2, .struct):           paletteLight = try Palette.read(from: proto)
        case (3, .struct):           paletteDark = try Palette.read(from: proto)
        case (4, .i32):             preferredNumberOfColumns = try Int32.read(from: proto)
        case (5, .struct):           thrasher = try Thrasher.read(from: proto)
        case (6, .i32):             type = try RowType.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(type, named: "type")

    return Row(columns: columns, paletteLight: paletteLight, paletteDark: paletteDark, preferredNumberOfColumns: preferredNumberOfColumns, thrasher: thrasher, type: type)
  }

}



public func ==(lhs: Collection, rhs: Collection) -> Bool {
  return
    (lhs.id == rhs.id) &&
    (lhs.paletteLight == rhs.paletteLight) &&
    (lhs.paletteDark == rhs.paletteDark) &&
    (lhs.rows == rhs.rows) &&
    (lhs.title == rhs.title)
}

extension Collection : CustomStringConvertible {

  public var description : String {
    var desc = "Collection("
    desc += "id=\(String(describing: self.id)), "
    desc += "paletteLight=\(String(describing: self.paletteLight)), "
    desc += "paletteDark=\(String(describing: self.paletteDark)), "
    desc += "rows=\(String(describing: self.rows)), "
    desc += "title=\(String(describing: self.title))"
    return desc
  }

}

extension Collection : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(id)
    hasher.combine(paletteLight)
    hasher.combine(paletteDark)
    hasher.combine(rows)
    hasher.combine(title)
  }

}

extension Collection : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["id": 1, "paletteLight": 2, "paletteDark": 3, "rows": 4, "title": 5, ]
  }

  public static var structName: String { return "Collection" }

  public static func read(from proto: TProtocol) throws -> Collection {
    _ = try proto.readStructBegin()
    var id: String!
    var paletteLight: Palette?
    var paletteDark: Palette?
    var rows: TList<Row>!
    var title: String?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           id = try String.read(from: proto)
        case (2, .struct):           paletteLight = try Palette.read(from: proto)
        case (3, .struct):           paletteDark = try Palette.read(from: proto)
        case (4, .list):            rows = try TList<Row>.read(from: proto)
        case (5, .string):           title = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(id, named: "id")
    try proto.validateValue(rows, named: "rows")

    return Collection(id: id, paletteLight: paletteLight, paletteDark: paletteDark, rows: rows, title: title)
  }

}



